name: Reconcile Prod Instance Upgrade Window

on:
  workflow_dispatch:
  schedule:
    # GitHub's minimum cron interval is 5 minutes.
    - cron: "*/5 * * * *"

permissions:
  contents: write
  actions: write

concurrency:
  group: prod-instance-upgrade-window-reconciler
  cancel-in-progress: false

jobs:
  reconcile:
    name: Reconcile production service plans for upgrade window
    runs-on: ubuntu-latest
    steps:
      - name: Load configured upgrade window
        id: window
        env:
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          ARTIFACT_NAME="prod-instance-upgrade-window"
          LIST_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts?name=${ARTIFACT_NAME}&per_page=100"

          list_status=$(curl -sS -o /tmp/window_artifacts.json -w "%{http_code}" \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$LIST_URL")

          if [ "$list_status" != "200" ]; then
            echo "::error::Unable to list window artifacts (HTTP ${list_status})."
            cat /tmp/window_artifacts.json
            exit 1
          fi

          artifact_json="$(jq -c '[.artifacts[] | select(.expired == false)] | sort_by(.created_at, .id) | last // empty' /tmp/window_artifacts.json)"
          if [ -z "$artifact_json" ]; then
            echo "::notice::No active upgrade window artifact found (${ARTIFACT_NAME})."
            echo "configured=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          artifact_id="$(echo "$artifact_json" | jq -r '.id // empty')"
          artifact_created_at="$(echo "$artifact_json" | jq -r '.created_at // empty')"
          archive_url="$(echo "$artifact_json" | jq -r '.archive_download_url // empty')"

          if [ -z "$artifact_id" ] || [ -z "$archive_url" ]; then
            echo "::error::Artifact metadata is incomplete."
            echo "$artifact_json"
            exit 1
          fi

          download_status=$(curl -sS -L -o /tmp/window_artifact.zip -w "%{http_code}" \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$archive_url")

          if [ "$download_status" -ge 300 ]; then
            echo "::error::Unable to download window artifact (HTTP ${download_status})."
            exit 1
          fi

          if ! unzip -p /tmp/window_artifact.zip instance-window.json > window.json 2>/dev/null; then
            echo "::error::Window artifact does not contain instance-window.json."
            exit 1
          fi

          if ! jq -e . window.json >/dev/null 2>&1; then
            echo "::error::Window payload is not valid JSON."
            cat window.json
            exit 1
          fi

          enabled="$(jq -r '.enabled // true' window.json)"
          if [ "$enabled" != "true" ]; then
            echo "::notice::Upgrade window is disabled."
            echo "configured=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          service_names_json="$(jq -c '.service_names // .services // []' window.json)"
          service_from_plan="$(jq -r '.service_from_plan // .from_plan // empty' window.json)"
          service_to_plan="$(jq -r '.service_to_plan // .to_plan // empty' window.json)"
          start_epoch="$(jq -r '.start_epoch // empty' window.json)"
          end_epoch="$(jq -r '.end_epoch // empty' window.json)"
          start_utc="$(jq -r '.start_utc // empty' window.json)"
          end_utc="$(jq -r '.end_utc // empty' window.json)"

          if [ -z "$service_from_plan" ] || [ -z "$service_to_plan" ] || [ -z "$start_epoch" ]; then
            echo "::error::Window payload is missing required fields."
            cat window.json
            exit 1
          fi

          if ! echo "$service_names_json" | jq -e 'type == "array" and length > 0 and all(.[]; (type == "string") and (length > 0))' >/dev/null; then
            echo "::error::service_names must be a non-empty array of non-empty strings."
            cat window.json
            exit 1
          fi

          case "$start_epoch" in
            (*[!0-9]*|'')
              echo "::error::start_epoch must be a unix epoch."
              exit 1
              ;;
          esac

          if [ -n "$end_epoch" ]; then
            case "$end_epoch" in
              (*[!0-9]*)
                echo "::error::end_epoch must be a unix epoch when set."
                exit 1
                ;;
            esac
          fi

          now_epoch="$(date -u +%s)"
          now_utc="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

          if [ "$now_epoch" -lt "$start_epoch" ]; then
            phase="before_start"
            target_service_plan="$service_from_plan"
          elif [ -n "$end_epoch" ] && [ "$now_epoch" -ge "$end_epoch" ]; then
            phase="after_end"
            target_service_plan="$service_from_plan"
          else
            phase="inside_window"
            target_service_plan="$service_to_plan"
          fi

          service_count="$(echo "$service_names_json" | jq 'length')"
          echo "::notice::Current phase: ${phase}; target service plan: ${target_service_plan}; services=${service_count}"

          {
            echo "configured=true"
            echo "artifact_id=$artifact_id"
            echo "artifact_created_at=$artifact_created_at"
            echo "service_names_json=$service_names_json"
            echo "target_service_plan=$target_service_plan"
            echo "phase=$phase"
            echo "service_from_plan=$service_from_plan"
            echo "service_to_plan=$service_to_plan"
            echo "start_utc=$start_utc"
            echo "end_utc=$end_utc"
            echo "end_epoch=$end_epoch"
            echo "now_utc=$now_utc"
          } >> "$GITHUB_OUTPUT"

      - name: Checkout default branch
        if: steps.window.outputs.configured == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.repository.default_branch || github.ref_name }}
          fetch-depth: 0

      - name: Resolve Render services and Blueprint for target services
        if: steps.window.outputs.configured == 'true'
        id: blueprint
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          SERVICE_NAMES_JSON: ${{ steps.window.outputs.service_names_json }}
        run: |
          set -euo pipefail

          if [ -z "${RENDER_API_KEY:-}" ]; then
            echo "::error::Missing required secret RENDER_API_KEY."
            exit 1
          fi

          if [ -z "${SERVICE_NAMES_JSON:-}" ]; then
            echo "::error::Missing service names payload."
            exit 1
          fi

          normalized_service_names="$(echo "$SERVICE_NAMES_JSON" | jq -c 'if type == "array" then map(tostring) else [] end')"
          if ! echo "$normalized_service_names" | jq -e 'length > 0 and all(.[]; length > 0)' >/dev/null; then
            echo "::error::SERVICE_NAMES_JSON must contain one or more service names."
            exit 1
          fi

          service_map_json="[]"
          while IFS= read -r service_name; do
            encoded_service_name="$(printf '%s' "$service_name" | jq -sRr @uri)"
            service_resp="$(curl -sS -w "\n%{http_code}" \
              "https://api.render.com/v1/services?name=${encoded_service_name}&limit=1" \
              -H "Authorization: Bearer ${RENDER_API_KEY}" \
              -H "Accept: application/json")"

            service_body="$(echo "$service_resp" | head -n -1)"
            service_status="$(echo "$service_resp" | tail -n 1)"

            if [ "$service_status" -ge 300 ]; then
              echo "::error::Failed to fetch Render service '${service_name}' (HTTP ${service_status})."
              echo "$service_body"
              exit 1
            fi

            service_id="$(echo "$service_body" | jq -r '.[0].service.id // .[0].id // empty')"
            service_type="$(echo "$service_body" | jq -r '.[0].service.type // .[0].type // empty')"

            if [ -z "$service_id" ]; then
              echo "::error::Render service not found: ${service_name}"
              exit 1
            fi

            if [ "$service_type" != "web_service" ]; then
              echo "::error::Expected '${service_name}' to be a web service, found '${service_type}'."
              exit 1
            fi

            service_map_json="$(echo "$service_map_json" | jq -c --arg name "$service_name" --arg id "$service_id" '. + [{name:$name,id:$id}]')"
          done < <(echo "$normalized_service_names" | jq -r '.[]')

          service_ids_json="$(echo "$service_map_json" | jq -c '[.[].id]')"

          blueprints_resp="$(curl -sS -w "\n%{http_code}" \
            "https://api.render.com/v1/blueprints?limit=100" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Accept: application/json")"

          blueprints_body="$(echo "$blueprints_resp" | head -n -1)"
          blueprints_status="$(echo "$blueprints_resp" | tail -n 1)"

          if [ "$blueprints_status" -ge 300 ]; then
            echo "::error::Failed to list Render blueprints (HTTP ${blueprints_status})."
            echo "$blueprints_body"
            exit 1
          fi

          blueprint_ids="$(echo "$blueprints_body" | jq -r '.[]?.blueprint?.id // .[]?.id // empty')"
          if [ -z "$blueprint_ids" ]; then
            echo "::error::No Render blueprints were found for this API key."
            exit 1
          fi

          matched_blueprint_id=""
          matched_blueprint_name=""
          matched_blueprint_path=""
          matched_auto_sync=""
          matched_last_sync=""

          for blueprint_id in $blueprint_ids; do
            detail_resp="$(curl -sS -w "\n%{http_code}" \
              "https://api.render.com/v1/blueprints/${blueprint_id}" \
              -H "Authorization: Bearer ${RENDER_API_KEY}" \
              -H "Accept: application/json")"

            detail_body="$(echo "$detail_resp" | head -n -1)"
            detail_status="$(echo "$detail_resp" | tail -n 1)"

            if [ "$detail_status" -ge 300 ]; then
              echo "::warning::Could not retrieve blueprint ${blueprint_id} (HTTP ${detail_status}); skipping."
              continue
            fi

            all_present=true
            while IFS= read -r service_item; do
              service_id="$(echo "$service_item" | jq -r '.id // empty')"
              service_name="$(echo "$service_item" | jq -r '.name // empty')"

              if ! echo "$detail_body" | jq -e --arg sid "$service_id" --arg sn "$service_name" '.resources[]? | select((.id == $sid) or (.name == $sn and .type == "web_service"))' >/dev/null; then
                all_present=false
                break
              fi
            done < <(echo "$service_map_json" | jq -c '.[]')

            if [ "$all_present" = "true" ]; then
              matched_blueprint_id="$blueprint_id"
              matched_blueprint_name="$(echo "$detail_body" | jq -r '.name // empty')"
              matched_blueprint_path="$(echo "$detail_body" | jq -r '.path // empty')"
              matched_auto_sync="$(echo "$detail_body" | jq -r '.autoSync // false')"
              matched_last_sync="$(echo "$detail_body" | jq -r '.lastSync // empty')"
              break
            fi
          done

          if [ -z "$matched_blueprint_id" ]; then
            echo "::error::No Blueprint managing all target services was found."
            echo "::error::All target services must be managed by the same Render Blueprint."
            exit 1
          fi

          echo "::notice::Matched Blueprint id='${matched_blueprint_id}', name='${matched_blueprint_name}', path='${matched_blueprint_path}', autoSync='${matched_auto_sync}', lastSync='${matched_last_sync}'"
          {
            echo "service_map_json=${service_map_json}"
            echo "service_ids_json=${service_ids_json}"
            echo "blueprint_id=${matched_blueprint_id}"
            echo "blueprint_auto_sync=${matched_auto_sync}"
            echo "blueprint_last_sync=${matched_last_sync}"
          } >> "$GITHUB_OUTPUT"

      - name: Enable Blueprint autoSync
        if: steps.window.outputs.configured == 'true' && steps.blueprint.outputs.blueprint_auto_sync != 'true'
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          BLUEPRINT_ID: ${{ steps.blueprint.outputs.blueprint_id }}
        run: |
          set -euo pipefail

          patch_resp="$(curl -sS -w "\n%{http_code}" \
            -X PATCH "https://api.render.com/v1/blueprints/${BLUEPRINT_ID}" \
            -H "Authorization: Bearer ${RENDER_API_KEY}" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -d '{"autoSync":true}')"

          patch_body="$(echo "$patch_resp" | head -n -1)"
          patch_status="$(echo "$patch_resp" | tail -n 1)"

          if [ "$patch_status" -ge 300 ]; then
            echo "::error::Failed to enable autoSync on blueprint ${BLUEPRINT_ID} (HTTP ${patch_status})."
            echo "$patch_body"
            exit 1
          fi

          echo "::notice::Enabled autoSync for blueprint ${BLUEPRINT_ID}."

      - name: Reconcile render.yaml plans for production services
        if: steps.window.outputs.configured == 'true'
        id: file-plan
        env:
          SERVICE_NAMES_JSON: ${{ steps.window.outputs.service_names_json }}
          TARGET_SERVICE_PLAN: ${{ steps.window.outputs.target_service_plan }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          set -euo pipefail

          branch="${DEFAULT_BRANCH:-${GITHUB_REF_NAME}}"
          git fetch origin "$branch"
          git checkout -B "$branch" "origin/$branch"
          git pull --ff-only origin "$branch"

          python - <<'PY'
          import json
          import os
          import re

          path = "render.yaml"
          target_service_plan = os.environ["TARGET_SERVICE_PLAN"].strip()
          service_names_json = os.environ["SERVICE_NAMES_JSON"].strip()

          if not target_service_plan:
              raise SystemExit("TARGET_SERVICE_PLAN is required.")
          if not service_names_json:
              raise SystemExit("SERVICE_NAMES_JSON is required.")

          service_names = json.loads(service_names_json)
          if (
              not isinstance(service_names, list)
              or not service_names
              or any(not isinstance(name, str) or not name.strip() for name in service_names)
          ):
              raise SystemExit("SERVICE_NAMES_JSON must be a non-empty JSON array of non-empty strings.")
          service_names = [name.strip() for name in service_names]
          target_service_names = set(service_names)

          with open(path, "r", encoding="utf-8") as f:
              lines = f.readlines()

          def indent_len(s: str) -> int:
              return len(s) - len(s.lstrip(" "))

          def find_production_bounds(lines_):
              start = None
              indent = None
              env_pattern = re.compile(r'^(\s*)-\s+name:\s*("?)([^"\n]+)\2\s*$')
              for idx, line in enumerate(lines_):
                  m = env_pattern.match(line)
                  if not m:
                      continue
                  name = m.group(3).strip()
                  if name.lower() == "production":
                      start = idx
                      indent = len(m.group(1))
                      break
              if start is None:
                  raise SystemExit(f"Production environment was not found in {path}.")

              end = len(lines_)
              for idx in range(start + 1, len(lines_)):
                  m = env_pattern.match(lines_[idx])
                  if m and len(m.group(1)) == indent:
                      end = idx
                      break
              return start, end, indent

          def find_services_bounds(lines_, prod_start, prod_end, prod_indent):
              services_indent = prod_indent + 2
              services_start = None
              for idx in range(prod_start + 1, prod_end):
                  if lines_[idx].strip() == "services:" and indent_len(lines_[idx]) == services_indent:
                      services_start = idx
                      break
              if services_start is None:
                  raise SystemExit("Production services block was not found in render.yaml.")

              services_end = prod_end
              for idx in range(services_start + 1, prod_end):
                  stripped = lines_[idx].strip()
                  if stripped and not stripped.startswith("#") and indent_len(lines_[idx]) <= services_indent:
                      services_end = idx
                      break
              return services_start, services_end, services_indent

          def find_target_service_items(lines_, services_start, services_end, services_indent, targets):
              item_indent = services_indent + 2
              item_starts = []
              item_start_pattern = re.compile(r'^(\s*)-\s+\w+:\s*.*$')

              for idx in range(services_start + 1, services_end):
                  m = item_start_pattern.match(lines_[idx])
                  if m and len(m.group(1)) == item_indent:
                      item_starts.append(idx)

              if not item_starts:
                  raise SystemExit("No services were found in Production services block.")

              item_starts.append(services_end)
              name_pattern = re.compile(r'^\s*name:\s*("?)([^"\n]+)\1\s*$')

              found = {}
              for i in range(len(item_starts) - 1):
                  start = item_starts[i]
                  end = item_starts[i + 1]
                  item_name = None
                  for idx in range(start, end):
                      m = name_pattern.match(lines_[idx])
                      if m:
                          item_name = m.group(2).strip()
                          break
                  if item_name and item_name in targets:
                      found[item_name] = (start, end, item_indent)

              missing = sorted(targets - set(found.keys()))
              if missing:
                  raise SystemExit(f"Missing production services in render.yaml: {', '.join(missing)}")

              return found

          production_start, production_end, production_indent = find_production_bounds(lines)
          services_start, services_end, services_indent = find_services_bounds(lines, production_start, production_end, production_indent)
          service_items = find_target_service_items(lines, services_start, services_end, services_indent, target_service_names)

          changed = False
          previous_plans = {}
          plan_pattern = re.compile(r'^(\s*plan:\s*)([^#\n]+?)(\s*(?:#.*)?)$')

          for service_name in service_names:
              service_start, service_end, service_item_indent = service_items[service_name]
              plan_idx = None
              for idx in range(service_start, service_end):
                  line = lines[idx].rstrip("\n")
                  m = plan_pattern.match(line)
                  if m and indent_len(lines[idx]) >= service_item_indent + 2:
                      plan_idx = idx
                      current_plan = m.group(2).strip().strip("'\"")
                      previous_plans[service_name] = current_plan
                      if current_plan != target_service_plan:
                          lines[idx] = f"{m.group(1)}{target_service_plan}{m.group(3)}\n"
                          changed = True
                      break

              if plan_idx is None:
                  raise SystemExit(f"Plan field for service '{service_name}' was not found.")

          if changed:
              with open(path, "w", encoding="utf-8") as f:
                  f.writelines(lines)

          output_file = os.environ["GITHUB_OUTPUT"]
          with open(output_file, "a", encoding="utf-8") as out:
              out.write(f"changed={'true' if changed else 'false'}\n")
              out.write(f"target_count={len(service_names)}\n")
              out.write(f"matched_count={len(service_items)}\n")
              out.write(f"previous_plans_json={json.dumps(previous_plans, separators=(',', ':'))}\n")
          PY

          echo "::notice::render.yaml plan reconciliation completed for production services targeting plan '${TARGET_SERVICE_PLAN}'."

      - name: Commit and push render.yaml plan changes
        if: steps.window.outputs.configured == 'true' && steps.file-plan.outputs.changed == 'true'
        id: push-plan
        env:
          TARGET_SERVICE_PLAN: ${{ steps.window.outputs.target_service_plan }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          set -euo pipefail

          branch="${DEFAULT_BRANCH:-${GITHUB_REF_NAME}}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add render.yaml
          git commit -m "chore(render): set production services plan to ${TARGET_SERVICE_PLAN} for upgrade window [skip ci]"

          attempt=1
          max_attempts=3
          while [ "$attempt" -le "$max_attempts" ]; do
            if git push origin "HEAD:${branch}"; then
              break
            fi

            if [ "$attempt" -eq "$max_attempts" ]; then
              echo "::error::Failed to push render.yaml plan change after ${max_attempts} attempts."
              exit 1
            fi

            attempt=$((attempt + 1))
            git fetch origin "$branch"
            git rebase "origin/${branch}"
          done

          commit_sha="$(git rev-parse HEAD)"
          echo "commit_sha=${commit_sha}" >> "$GITHUB_OUTPUT"
          echo "::notice::Pushed render.yaml plan update commit ${commit_sha}."

      - name: Wait for Blueprint sync after commit
        if: steps.window.outputs.configured == 'true' && steps.file-plan.outputs.changed == 'true'
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          BLUEPRINT_ID: ${{ steps.blueprint.outputs.blueprint_id }}
          LAST_SYNC_BEFORE: ${{ steps.blueprint.outputs.blueprint_last_sync }}
        run: |
          set -euo pipefail

          if [ -z "${BLUEPRINT_ID:-}" ]; then
            echo "::warning::Missing blueprint ID; skipping sync wait."
            exit 0
          fi

          baseline="${LAST_SYNC_BEFORE:-}"
          max_attempts=36
          sleep_seconds=10
          attempt=1

          while [ "$attempt" -le "$max_attempts" ]; do
            detail_resp="$(curl -sS -w "\n%{http_code}" \
              "https://api.render.com/v1/blueprints/${BLUEPRINT_ID}" \
              -H "Authorization: Bearer ${RENDER_API_KEY}" \
              -H "Accept: application/json")"

            detail_body="$(echo "$detail_resp" | head -n -1)"
            detail_status="$(echo "$detail_resp" | tail -n 1)"

            if [ "$detail_status" -ge 300 ]; then
              echo "::warning::Blueprint retrieve failed during sync wait (HTTP ${detail_status}); retrying."
            else
              current_last_sync="$(echo "$detail_body" | jq -r '.lastSync // empty')"
              echo "Sync wait ${attempt}/${max_attempts}: baseline='${baseline}', current='${current_last_sync}'"

              if [ -n "$current_last_sync" ] && [ "$current_last_sync" != "$baseline" ]; then
                echo "::notice::Detected Blueprint sync timestamp change: ${current_last_sync}"
                exit 0
              fi
            fi

            attempt=$((attempt + 1))
            sleep "$sleep_seconds"
          done

          echo "::warning::No Blueprint sync timestamp change detected within wait window."
          echo "::warning::Check Render dashboard Blueprint sync history to confirm reconciliation."

      - name: Delete completed window artifacts
        if: steps.window.outputs.configured == 'true' && steps.window.outputs.phase == 'after_end'
        env:
          GITHUB_TOKEN: ${{ github.token }}
          ARTIFACT_ID: ${{ steps.window.outputs.artifact_id }}
          ARTIFACT_CREATED_AT: ${{ steps.window.outputs.artifact_created_at }}
        run: |
          set -euo pipefail

          ARTIFACT_NAME="prod-instance-upgrade-window"
          LIST_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts?name=${ARTIFACT_NAME}&per_page=100"

          list_status=$(curl -sS -o /tmp/window_artifacts_cleanup.json -w "%{http_code}" \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$LIST_URL")

          if [ "$list_status" != "200" ]; then
            echo "::warning::Failed to list completed window artifacts for cleanup (HTTP ${list_status})."
            cat /tmp/window_artifacts_cleanup.json
            exit 0
          fi

          if [ -n "${ARTIFACT_CREATED_AT:-}" ]; then
            artifact_ids="$(jq -r --arg cutoff "$ARTIFACT_CREATED_AT" '.artifacts[]? | select(.expired == false) | select(.created_at <= $cutoff) | .id' /tmp/window_artifacts_cleanup.json)"
          elif [ -n "${ARTIFACT_ID:-}" ]; then
            artifact_ids="$ARTIFACT_ID"
          else
            artifact_ids=""
          fi

          if [ -z "$artifact_ids" ] && [ -n "${ARTIFACT_ID:-}" ]; then
            artifact_ids="$ARTIFACT_ID"
          fi

          if [ -z "$artifact_ids" ]; then
            echo "::notice::No active window artifacts found to delete."
            exit 0
          fi

          cleanup_errors=0
          for artifact_id in $artifact_ids; do
            delete_status=$(curl -sS -o "/tmp/window_artifact_delete_${artifact_id}.json" -w "%{http_code}" \
              -X DELETE \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts/${artifact_id}")

            if [ "$delete_status" != "204" ]; then
              echo "::warning::Failed to delete completed window artifact ${artifact_id} (HTTP ${delete_status})."
              cat "/tmp/window_artifact_delete_${artifact_id}.json"
              cleanup_errors=1
              continue
            fi

            echo "::notice::Deleted completed window artifact ${artifact_id}."
          done

          if [ "$cleanup_errors" -ne 0 ]; then
            echo "::warning::Cleanup finished with errors."
            exit 0
          fi
