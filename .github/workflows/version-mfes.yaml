name: Version MFEs

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (show what would be versioned without committing)'
        required: false
        type: boolean
        default: false

  # Automatically trigger when production deployments succeed
  deployment_status:

permissions:
  contents: write

jobs:
  version:
    name: Version MFEs and create git tags
    runs-on: ubuntu-latest
    # Only run if:
    # 1. Manual trigger, OR
    # 2. Production deployment succeeded
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.deployment_status.state == 'success' &&
       endsWith(github.event.deployment.environment, '-prod'))
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20.x
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Check for MFE changesets
        id: check-changesets
        run: |
          echo "Checking for MFE changesets..."

          # Determine how this workflow was triggered
          if [ "${{ github.event_name }}" = "deployment_status" ]; then
            TRIGGER_TYPE="automatic (production deployment)"
            ENV="${{ github.event.deployment.environment }}"
            echo "Triggered by: Production deployment to $ENV"
          else
            TRIGGER_TYPE="manual"
            echo "Triggered by: Manual workflow dispatch"
          fi

          # Check for MFE changesets using glob pattern
          HAS_MFE_CHANGESETS=false
          for file in .changeset/*.md; do
            [[ -f "$file" ]] || continue
            [[ "$(basename "$file")" == "README.md" ]] && continue
            if grep -q "@gfed-medusa/mf-" "$file" 2>/dev/null; then
              HAS_MFE_CHANGESETS=true
              break
            fi
          done

          if [ "$HAS_MFE_CHANGESETS" = "true" ]; then
            echo "has_mfe_changesets=true" >> "$GITHUB_OUTPUT"
            echo "âœ“ MFE changesets found"

            # Show which changesets will be consumed
            echo ""
            echo "Changesets that will be consumed:"
            for file in .changeset/*.md; do
              [[ -f "$file" ]] || continue
              [[ "$(basename "$file")" == "README.md" ]] && continue
              if grep -q "@gfed-medusa/mf-" "$file" 2>/dev/null; then
                echo "  - $(basename "$file")"
              fi
            done

            if [ "$TRIGGER_TYPE" = "automatic (production deployment)" ]; then
              echo ""
              echo "::notice::Automatic version bump triggered by production deployment"
            fi
          else
            echo "has_mfe_changesets=false" >> "$GITHUB_OUTPUT"

            # If triggered by deployment but no changesets, just skip quietly
            if [ "${{ github.event_name }}" = "deployment_status" ]; then
              echo "::notice::Production deployment succeeded but no MFE changesets found"
              echo "::notice::Skipping version bump - this is normal if no MFE changes were in this deployment"
              exit 0
            else
              # If manual trigger, warn the user
              echo "::warning::No MFE changesets found"
              echo "::warning::Add changesets with: pnpm changeset"
              exit 0
            fi
          fi

      - name: Version MFEs
        if: steps.check-changesets.outputs.has_mfe_changesets == 'true'
        run: |
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "ðŸ” DRY RUN MODE - Showing what would be versioned"
            echo ""
            pnpm exec changeset status --verbose
            echo ""
            echo "::notice::Dry run complete. No changes were made."
            echo "::notice::Run without dry_run to apply these changes."
          else
            if ! pnpm run ci:version-mfes; then
              echo "::error::Failed to version MFEs. Check changeset files for errors."
              exit 1
            fi
          fi

      - name: Check for version changes
        if: steps.check-changesets.outputs.has_mfe_changesets == 'true' && inputs.dry_run == false
        id: check-changes
        run: |
          if git diff --name-only | grep "apps/mf-.*/package.json" > /dev/null; then
            echo "versions_changed=true" >> "$GITHUB_OUTPUT"
            echo "âœ“ MFE versions were updated"

            # Show what changed
            echo ""
            echo "Updated versions:"
            for package in apps/mf-*/package.json; do
              if git diff --name-only | grep -q "$package"; then
                NAME=$(jq -r '.name' "$package" | sed 's/@gfed-medusa\/mf-//')
                VERSION=$(jq -r '.version' "$package")
                echo "  - $NAME â†’ $VERSION"
              fi
            done
          else
            echo "versions_changed=false" >> "$GITHUB_OUTPUT"
            echo "::warning::No MFE version changes detected"
            echo "::warning::This might happen if changesets only affect packages, not MFEs"
          fi

      - name: Commit version updates and create tags
        if: steps.check-changes.outputs.versions_changed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "Version MFEs"

          # Create git tags BEFORE pushing commit to avoid race condition
          echo "Creating git tags for versioned MFEs..."
          TAGS_CREATED=""
          for package in apps/mf-*/package.json; do
            NAME=$(jq -r '.name' "$package")
            VERSION=$(jq -r '.version' "$package")
            TAG="$NAME@$VERSION"

            # Only create tag if it doesn't exist
            if git rev-parse "$TAG" >/dev/null 2>&1; then
              echo "::warning::Tag $TAG already exists, skipping"
            else
              git tag "$TAG"
              echo "Created tag: $TAG"
              TAGS_CREATED="$TAGS_CREATED $TAG"
            fi
          done

          # Push commit and tags together atomically
          # This ensures tags exist before deploy workflow starts
          echo ""
          echo "Pushing version commit and tags to main..."
          if ! git push origin main --follow-tags; then
            echo "::error::Failed to push version commit and tags"
            exit 1
          fi

          echo "::notice::âœ“ Version commit and git tags pushed successfully"
          echo "::notice::Tags created:$TAGS_CREATED"
          echo "::notice::Deploy workflow will now run with new versions"

      - name: Summary
        if: always() && steps.check-changesets.outputs.has_mfe_changesets == 'true'
        run: |
          # Determine trigger source for summary
          if [ "${{ github.event_name }}" = "deployment_status" ]; then
            DEPLOY_ENV="${{ github.event.deployment.environment }}"
            TRIGGER_MSG="ðŸŽ¯ Triggered automatically after production"
            TRIGGER_MSG="$TRIGGER_MSG deployment to \`$DEPLOY_ENV\`"
          else
            TRIGGER_MSG="ðŸ”§ Triggered manually"
          fi

          if [ "${{ inputs.dry_run }}" = "true" ]; then
            {
              echo "## ðŸ” Dry Run - Version Preview"
              echo ""
              echo "$TRIGGER_MSG"
              echo ""
              echo "No changes were made. Run without dry_run to apply these versions."
              echo ""
              echo "### Pending Changesets"
              echo ""
            } >> "$GITHUB_STEP_SUMMARY"

            # Check if any changesets exist
            HAS_CHANGESETS=false
            for file in .changeset/*.md; do
              [[ -f "$file" ]] || continue
              [[ "$(basename "$file")" == "README.md" ]] && continue
              HAS_CHANGESETS=true
              break
            done

            if [ "$HAS_CHANGESETS" = "true" ]; then
              {
                echo "| Changeset File |"
                echo "|----------------|"
              } >> "$GITHUB_STEP_SUMMARY"

              for file in .changeset/*.md; do
                [[ -f "$file" ]] || continue
                [[ "$(basename "$file")" == "README.md" ]] && continue
                echo "| $(basename "$file") |" >> "$GITHUB_STEP_SUMMARY"
              done
            fi
          elif [ "${{ steps.check-changes.outputs.versions_changed }}" = "true" ]; then
            {
              echo "## âœ… MFE Versions Updated"
              echo ""
              echo "$TRIGGER_MSG"
              echo ""
              echo "| MFE | New Version | Git Tag |"
              echo "|-----|-------------|---------|"
            } >> "$GITHUB_STEP_SUMMARY"

            for package in apps/mf-*/package.json; do
              NAME=$(jq -r '.name' "$package" | sed 's/@gfed-medusa\/mf-//')
              FULL_NAME=$(jq -r '.name' "$package")
              VERSION=$(jq -r '.version' "$package")
              echo "| $NAME | $VERSION | \`$FULL_NAME@$VERSION\` |" >> "$GITHUB_STEP_SUMMARY"
            done

            if [ "${{ github.event_name }}" = "deployment_status" ]; then
              FINAL_MSG="ðŸŽ‰ **Production release complete!**"
              FINAL_MSG="$FINAL_MSG Version numbers now reflect what's in production."
            else
              FINAL_MSG="ðŸš€ Deploy workflow will now run automatically"
              FINAL_MSG="$FINAL_MSG with these new versions."
            fi

            {
              echo ""
              echo "$FINAL_MSG"
            } >> "$GITHUB_STEP_SUMMARY"
          fi
